"""
Module for building automatically the doc of the API messages in markdown format.
"""

from messages import *
import inspect

gitlab_url = 'https://gitlab.f-interop.eu/f-interop-contributors/utils/blob/master/messages.py'
header = """Messages format

This section describes the format of the messages used by the testing tool.

This section of the documentation is autogenerated by
[tool](https://gitlab.f-interop.eu/f-interop-contributors/utils/blob/master/messages_doc.py)

Version %s
""" %API_VERSION

services = []
events = []

def message_amqp_section(file, message_instance):
    file.write("\n\n```amqp")
    file.write("\n %s" % message_instance)
    file.write("\n ```")
    return

def message_json_section(file, message_instance):
    file.write("\n\n```json")
    file.write("\n %s" % json.dumps(message_instance.to_dict(),indent=4,))
    file.write("\n ```")
    return

def print_doc_tables(services, events):
    """

    expected result (this method cannot do all this, some modifs need to be done manually)

    ### API services

    TBD provides the following services:

    |SERVICES | DESCRIPTION|
    |---| ---|
    |[*testcoordination.testsuite.getstatus*](#testcoordination-testsuite-getstatus) | Message for debugging purposes. The coordination component returns the status of the execution |
    |[*testcoordination.testsuite.gettestcases*](#testcoordination-testsuite-gettestcases) | Message for requesting the list of test cases included in the test suite.|

    ### API events

    TBD listens and consumes the following messages from the bus:

    |MESSAGES CONSUMED | DESCRIPTION|
    |---| ---|
    |[*testcoordination.testsuite.start*](#testcoordination-testsuite-start) | Message for triggering start of test suite. The command is given by one of the users of the session.|
    |[*testcoordination.testsuite.abort*](#testcoordination-testsuite-abort)| Message for aborting the ongoing test session.|
    |[*testcoordination.testcase.skip*](#testcoordination-testcase-skip) | Message for skipping a test case. Coordinator passes to the next test case if there is any left.|

    Coordinator generates and publishes the following messages:

    |MESSAGES PUBLISHED | DESCRIPTION|
    |---| ---|
    |[*testcoordination.testcase.next*](#testcoordination-testcase-next) | Indicates next testcase to be executed |
    |[*testcoordination.testsuite.finished*](#testcoordination-testsuite-finished) | Indicates there's no more test cases to execute |
    |[*testcoordination.error*](#testcoordination-error) | Message used to indicate errors on coordiation component |


    """

    head_1 = """### API services

TBD provides the following services:

|SERVICES | DESCRIPTION|
|---| ---|"""

    head_2 = """### API events

TBD listens and consumes the following messages from the bus:

|MESSAGES CONSUMED | DESCRIPTION|
|---| ---|"""

    head_3 = """TBD generates and publishes the following messages:

|MESSAGES PUBLISHED | DESCRIPTION|
|---| ---|"""

    def table_row(event_type):
        s=""
        s+="|[*%s*](#%s) | Some description that needs to be writen manually |"\
           %(
            event_type,
            event_type.replace('.','-')
           )
        return s

    print(head_1)
    for s in services:
        print(table_row(s._type))

    print()
    print()
    print(head_2)
    for e in events:
        print(table_row(e._type))

    print()
    print()
    print(head_3)
    for e in events:
        print(table_row(e._type))



if __name__ == '__main__':

    with open('_messages.md', "w+") as f:

        # Message Type
        f.write('# %s' % (header))

        for msg_type, msg_class in sorted(message_types_dict.items()):

            # Message Type
            f.write('\n\n\n## %s' %(msg_type))

            # Message docstring
            f.write('\n\n### Description:\n%s' % (msg_class.__doc__))

            # Message code source:
            line_number = (inspect.findsource(msg_class)[1])
            url = gitlab_url + "#L%s" %line_number
            f.write('\n\n### Source code: \n[%s](%s)\n' %(msg_class.__name__,url))

            # Message's fields table
            # TODO do we need this?


            msg_instance = None

            # Messages's example AMQP + JSON
            if 'reply' not in msg_class.__name__.lower(): # Message is not a reply
                msg_instance = msg_class()

            else: # Message is a reply -> we need to generate it using a request
                reply_class_name = msg_class.__name__
                request_class_name = ''

                if 'reply' in msg_class.__name__:
                    request_class_name = reply_class_name.replace("reply", '')
                elif 'Reply' in msg_class.__name__:
                    request_class_name = reply_class_name.replace("Reply", '')
                else:
                    raise Exception('cannot process message event: %s' %msg_type)

                request_instance = globals()[request_class_name]()
                msg_instance = msg_class(request_message = request_instance)

            # add the amqo + json section
            message_amqp_section(f,msg_instance)
            message_json_section(f, msg_instance)

            if 'service' in msg_instance.routing_key:
                services.append(msg_instance)
            else:
                events.append(msg_instance)

    print_doc_tables(services, events)

